В mikrotik репозиторий скриптов можно найти в меню system scripts

В начале скрипта располагаются настройки. 

:local - это оператор создания локальной переменной.

Данная переменная указывает лимит в рублях, ниже которого скрипт будет отсылать оповещения (все операторы, связанные со скриптами, начинаются с двоеточия)

:local threshold 100

Данная группа переменных отвечает за настройки почты для отправки письма

:local to
:local from
:local subject
:local smtpServer
:local smtpPort 25

Далее идёт группа служебных переменных, в первую из них будет записан ответ мегафона на USSD-запрос

:local answer

В эту переменную будет извлечена регулярным выражением из ответа мегафона и записана непосредственно строка символов 0-9 a-f, каждый из которых кодирует шестнадцатеричное число, которые в свою очередь кодируют строку символов в кодировке Unicode UCS2

:local encodedBalance

RouterOS не умеет работать с Unicode UCS2 и с русским языком, поэтому переменная выше будет парситься, и в переменную ниже попадут только числа

:local decodedBalance ""

Ответ мегафона будет содержать много служебной информации, непосредственно же строка с необходимой информацией начинается с данного символа

:local startToken "CUSD: 0,\""

И заканчивается этим символом

:local endToken "\","

Данные переменные указывают на позицию в символах в ответе мегафона собственно самого ответа среди служебной информации

:local startPos
:local endPos

Данные переменные представляют собой счётчик и лимит для цикла

:local maxTry 15;
:local tryCount 0;

Сам цикл

:do {

Выполнение USSD запроса на номер *923# и запись его в переменную answer, квадратные скобки позволяют выполнить команду и передать результат её выполнения оператору за скобками, в данном случае это оператор :set, который изменяет значение переменной, параметр “as-value” нужен чтобы команда at-chat передала свой вывод как значение, иначе она выведет результат прямо на консоль

	:set answer [/interface lte at-chat lte1 input="AT+CUSD=1,\"*923#\",15" wait=yes as-value]

Параметр input="AT+CUSD=1,\"*923#\",15" указывает собственно строку запроса USSD, её можно найти на wiki mikrotik

Ответ представляет собой массив, в первом элементе которого находится собственно весь текст ответа, а во втором пустая строка. Поэтому нужно перезаписать этот массив строкой из первого элемента

	:set answer [:pick $answer 0]

Инкрементируем счётчик

	:set tryCount ($tryCount+1)

Проверка счетчика и условия, так как в ответе сервера может и не быть собственно ответа, а только служебная информация, чаще всего это происходит при отрицательном балансе, признаком наличия нужной информации может служить подстрока, с которой подстрока с балансом обычно начинается 

	} while=(!($answer~$startToken) and ($tryCount<=$maxTry))

Если цикл прокрутился все пятнадцать раз, то это значит, что нет ответа от мегафона, делаем запись в лог и отсылаем письмо об этом

:if ($tryCount>=$maxTry) do={
	[:log warning "check balance: no reply from Megaphon"]
	/tool e-mail send server=$smtpServer port=$smtpPort from=$from body="no reply from Megaphon, may be it is no money" start-tls=no subject=$subject to=$to

Оператор :error позволяет завершить выполнение скрипта

	:error "no reply from Megaphon"}

Позиционируем указатель на начало подстроки с необходимой информацией в ответе мегафона, -1 указывает оператору :find, искать с самого начала строки в переменной answer

:set startPos [:find $answer $startToken -1]

Передвигаем указатель за позицию, с которой начинается нужная информация

:set startPos ($startPos+9)

Теперь передвигаем указатель конца нужной подстроки с балансом в ответе мегафона, поиск начинаем с начала этой подстроки

:set endPos [:find $answer $endToken $startPos]

Теперь работаем с ответом мегафона не как со строкой, а как с массивом символов, вырезаем оттуда все элементы между двух указателей и записываем в переменную с закодированным в Unicode UCS2 балансом

:set encodedBalance [:pick $answer $startPos $endPos]

Сообщение с балансом неизменно начинается с “Ваш баланс: “, поэтому необходимо сразу передвинуть указатель. В данной кодировке каждый символ кодируется четырьмя шестнадцатеричными числами, а каждое число в строковой переменной выше закодировано одним символом, что даёт шаг как раз в четыре символа

:set $startPos 28
:set $endPos 32

Теперь текущий закодированный символ находится между двух указателей, и его можно записать в переменную для раскодировки

:local currentSymbol [:pick $encodedBalance $startPos $endPos]

Условие проверки символа - это точка, которая кодируется шестнадцатиричным числом 002e. Точкой в балансе мегафон отделяет копейки от рублей, но mikrotik умеет работать только с целыми числам. Нам эти копейки тоже не интересны.

:while (!($currentSymbol="002e")) do={

Отрицательный баланс начинается с минуса, который кодируется числом "002d", при наличии он конкатенируется как строка к строке (пока что ещё пустой), которая содержится в переменной с декодированным балансом. Необходимость использования условного оператора :if вызвана тем, что нет универсального способа декодировать и числа, и знак минуса. Оператора continue в RouterOS нет, поэтому используется else

	:if ($currentSymbol="002d") do={
    	:set decodedBalance ($decodedBalance . "-")} else={

Все цифры в Unicode UCS2 имеют вид 003X, где Х - это цифра от 0 до 9. При конвертации такой строки в целочисленный тип нули в начале будут отброшены. Большая удача, что все факторы сошлись именно так. Теперь чтобы получить окончательно декодировать саму цифру, из полученного числа достаточно вычесть 30 и конвертировать число обратно в строку. Хранение значения именно в строковом типе даёт возможность конкатенации с каждым последующим числом (хотя вряд ли их будет больше трёх)

        	:set decodedBalance ($decodedBalance . [:tostr ([:tonum $currentSymbol]-30)])}

Передвигаем указатели

	:set startPos ($startPos+4)
	:set endPos ($endPos+4)

Записываем в переменную следующий символ для декодирования

	:set $currentSymbol [:pick $encodedBalance $startPos $endPos]}

После окончания работы цикла нужно опять конвертировать переменную чтобы была возможность сравнить её с порогом минимального баланса.

:set decodedBalance [:tonum $decodedBalance]

Здесь всё просто, если баланс достиг минимального уровня, отсылаем письмо и делаем запись в лог

:if ($decodedBalance<=$threshold) do={
	/tool e-mail send server=$smtpServer port=$smtpPort from=$from body="Balance $decodedBalance rub." start-tls=no subject=$subject to=$to
	:log warning "check balance: $decodedBalance"} else={:log info "check balance: $decodedBalance"}


Онлай декодировщик https://smspdu.benjaminerhart.com/
